from arpeggio.utils import isstr as isstr
from typing import Any, Optional as _Optional

text = str
DEFAULT_WS: str
NOMATCH_MARKER: int

class ArpeggioError(Exception):
    message: Any = ...
    def __init__(self, message: Any) -> None: ...

class GrammarError(ArpeggioError): ...
class SemanticError(ArpeggioError): ...

class NoMatch(Exception):
    rules: Any = ...
    position: Any = ...
    parser: Any = ...
    def __init__(self, rules: Any, position: Any, parser: Any) -> None: ...
    def __unicode__(self): ...

def flatten(_iterable: Any): ...

class DebugPrinter:
    debug: Any = ...
    file: Any = ...
    def __init__(self, **kwargs: Any) -> None: ...
    def dprint(self, message: Any, indent_change: int = ...) -> None: ...

class ParsingExpression:
    suppress: bool = ...
    elements: Any = ...
    rule_name: Any = ...
    root: Any = ...
    nodes: Any = ...
    def __init__(self, *elements: Any, **kwargs: Any) -> None: ...
    @property
    def desc(self): ...
    @property
    def name(self): ...
    @property
    def id(self): ...
    def parse(self, parser: Any): ...

class Sequence(ParsingExpression):
    ws: Any = ...
    skipws: Any = ...
    def __init__(self, *elements: Any, **kwargs: Any) -> None: ...

class OrderedChoice(Sequence): ...

class Repetition(ParsingExpression):
    eolterm: Any = ...
    sep: Any = ...
    def __init__(self, *elements: Any, **kwargs: Any) -> None: ...

class Optional(Repetition): ...
class ZeroOrMore(Repetition): ...
class OneOrMore(Repetition): ...
class UnorderedGroup(Repetition): ...
class SyntaxPredicate(ParsingExpression): ...
class And(SyntaxPredicate): ...
class Not(SyntaxPredicate): ...
class Empty(SyntaxPredicate): ...
class Decorator(ParsingExpression): ...
class Combine(Decorator): ...

class Match(ParsingExpression):
    def __init__(self, rule_name: Any, root: bool = ..., **kwargs: Any) -> None: ...
    @property
    def name(self): ...
    def parse(self, parser: Any): ...

class RegExMatch(Match):
    to_match_regex: Any = ...
    ignore_case: Any = ...
    multiline: Any = ...
    explicit_flags: Any = ...
    to_match: Any = ...
    def __init__(self, to_match: Any, rule_name: str = ..., root: bool = ..., ignore_case: _Optional[Any] = ..., multiline: _Optional[Any] = ..., str_repr: _Optional[Any] = ..., re_flags: Any = ..., **kwargs: Any) -> None: ...
    regex: Any = ...
    def compile(self) -> None: ...
    def __unicode__(self): ...

class StrMatch(Match):
    to_match: Any = ...
    ignore_case: Any = ...
    def __init__(self, to_match: Any, rule_name: str = ..., root: bool = ..., ignore_case: _Optional[Any] = ..., **kwargs: Any) -> None: ...
    def __unicode__(self): ...
    def __eq__(self, other: Any) -> Any: ...
    def __hash__(self) -> Any: ...

class Kwd(StrMatch):
    to_match: Any = ...
    root: bool = ...
    rule_name: str = ...
    def __init__(self, to_match: Any) -> None: ...

class EndOfFile(Match):
    def __init__(self) -> None: ...
    @property
    def name(self): ...

def EOF(): ...

class ParseTreeNode:
    rule: Any = ...
    rule_name: Any = ...
    position: Any = ...
    error: Any = ...
    comments: Any = ...
    def __init__(self, rule: Any, position: Any, error: Any) -> None: ...
    @property
    def name(self): ...
    @property
    def position_end(self) -> None: ...
    def visit(self, visitor: Any): ...
    def tree_str(self, indent: int = ...): ...

class Terminal(ParseTreeNode):
    value: Any = ...
    suppress: Any = ...
    extra_info: Any = ...
    def __init__(self, rule: Any, position: Any, value: Any, error: bool = ..., suppress: bool = ..., extra_info: _Optional[Any] = ...) -> None: ...
    @property
    def desc(self): ...
    @property
    def position_end(self): ...
    def flat_str(self): ...
    def __unicode__(self): ...
    def tree_str(self, indent: int = ...): ...
    def __eq__(self, other: Any) -> Any: ...

class NonTerminal(ParseTreeNode, list):
    def __init__(self, rule: Any, nodes: Any, error: bool = ..., _filtered: bool = ...) -> None: ...
    @property
    def value(self): ...
    @property
    def desc(self): ...
    @property
    def position_end(self): ...
    def flat_str(self): ...
    def __unicode__(self): ...
    def tree_str(self, indent: int = ...): ...
    def __getattr__(self, rule_name: Any): ...

class PTNodeVisitor(DebugPrinter):
    for_second_pass: Any = ...
    defaults: Any = ...
    def __init__(self, defaults: bool = ..., **kwargs: Any) -> None: ...
    def visit__default__(self, node: Any, children: Any): ...

def visit_parse_tree(parse_tree: Any, visitor: Any): ...

class SemanticAction:
    def first_pass(self, parser: Any, node: Any, nodes: Any): ...

class SemanticActionResults(list):
    results: Any = ...
    def __init__(self) -> None: ...
    def append_result(self, name: Any, result: Any) -> None: ...
    def __getattr__(self, attr_name: Any): ...

class SemanticActionSingleChild(SemanticAction):
    def first_pass(self, parser: Any, node: Any, children: Any): ...

class SemanticActionBodyWithBraces(SemanticAction):
    def first_pass(self, parser: Any, node: Any, children: Any): ...

class SemanticActionToString(SemanticAction):
    def first_pass(self, parser: Any, node: Any, children: Any): ...

class Parser(DebugPrinter):
    FIRST_NOT: Any = ...
    skipws: Any = ...
    reduce_tree: Any = ...
    autokwd: Any = ...
    ignore_case: Any = ...
    memoization: Any = ...
    comments_model: Any = ...
    comments: Any = ...
    comment_positions: Any = ...
    sem_actions: Any = ...
    parse_tree: Any = ...
    keyword_regex: Any = ...
    in_rule: str = ...
    in_parse_comments: bool = ...
    in_lex_rule: bool = ...
    in_not: bool = ...
    last_pexpression: Any = ...
    def __init__(self, skipws: bool = ..., ws: _Optional[Any] = ..., reduce_tree: bool = ..., autokwd: bool = ..., ignore_case: bool = ..., memoization: bool = ..., **kwargs: Any) -> None: ...
    @property
    def ws(self): ...
    @ws.setter
    def ws(self, new_value: Any) -> None: ...
    @property
    def eolterm(self): ...
    @eolterm.setter
    def eolterm(self, new_value: Any) -> None: ...
    position: int = ...
    nm: Any = ...
    line_ends: Any = ...
    input: Any = ...
    file_name: Any = ...
    cache_hits: int = ...
    cache_misses: int = ...
    def parse(self, _input: Any, file_name: _Optional[Any] = ...): ...
    def parse_file(self, file_name: Any): ...
    def getASG(self, sem_actions: _Optional[Any] = ..., defaults: bool = ...): ...
    def pos_to_linecol(self, pos: Any): ...
    def context(self, length: _Optional[Any] = ..., position: _Optional[Any] = ...): ...

class CrossRef:
    target_rule_name: Any = ...
    position: Any = ...
    def __init__(self, target_rule_name: Any, position: int = ...) -> None: ...

class ParserPython(Parser):
    syntax_classes: Any = ...
    parser_model: Any = ...
    comments_model: Any = ...
    def __init__(self, language_def: Any, comment_def: _Optional[Any] = ..., syntax_classes: _Optional[Any] = ..., *args: Any, **kwargs: Any) -> None: ...
    def errors(self) -> None: ...
